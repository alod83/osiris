// Generated by CoffeeScript 1.10.0
(function() {
  var CELLSIZE, algorithm, basic_class, color, coordinates, countries_africa_g, countries_europe_g, draw_point_and_prediction, ellipse_g, height, lat, lat_hover, lon, lon_hover, max_speed, path_generator, point_line_g, prediction_g, projection, route_g, svg, time, width, zoom, zoomable_layer;

  CELLSIZE = 0.1;

  svg = d3.select('svg');

  width = svg.node().getBoundingClientRect().width;

  height = svg.node().getBoundingClientRect().height;

  time = 30;

  lat = 35.898;

  lon = 14.951;

  max_speed = 10;

  lat_hover = lat;

  lon_hover = lon;

  basic_class = 0;

  coordinates = [];

  algorithm = 'knn';


  /* ZOOM
   */

  projection = d3.geoEquirectangular().scale(height / Math.PI).translate([width / 2, height / 2]);
  
  
 
  zoomable_layer = svg.append('g');

  ellipse_g = zoomable_layer.append('g');

  route_g = zoomable_layer.append('g');

  prediction_g = zoomable_layer.append('g');
  
  
  countries_europe_g = zoomable_layer.append('g');

  countries_africa_g = zoomable_layer.append('g');

  point_line_g = zoomable_layer.append('g');
  
  
  zoom = d3.zoom().scaleExtent([-Infinity, Infinity]).on('zoom', function() {
    console.log(d3.event.transform);
    return zoomable_layer.attrs({
      transform: d3.event.transform
    });
  });
  //console.log(width);
  //console.log(height);
  //zoom_x = width*10;
  //zoom_y = height*2;
  //console.log(zoom_x);
  var state = {
  x: 0,
  y: 0,
  scale: 1
};

var oX = width;

var oY = height;

var scale = 40;
var scaleD = scale / state.scale;
  // The magic
  var x = scaleD * (state.x - oX) + oX;
  var y = scaleD * (state.x - oY) + oY;

  
   //{k: 36.80934058721951, x: -27120.851298810303, y: -7601.722456875037}
  // {k: 38.96211259721568, x: -28260.20024289637, y: -9551.884417693771}
  //zoomable_layer.attr("transform","translate(" + x + "," + y + ") scale(" + scale + ")");
 zoomable_layer.attr("transform","scale(height / Math.PI)");
  svg.call(zoom);
  
  //var transform = "matrix("+scale+",0,0,"+scale+","+x+","+y+")";

  zoomable_layer.on('mousedown.log', function() {
    lat = projection.invert(d3.mouse(this))[1];
    lon = projection.invert(d3.mouse(this))[0];
    coordinates = [lon, lat];
    return draw_point_and_prediction();
  });

  zoomable_layer.on('mousemove', function() {
    lat_hover = projection.invert(d3.mouse(this))[1];
    return lon_hover = projection.invert(d3.mouse(this))[0];
  });

  svg.call(zoom);

  path_generator = d3.geoPath().projection(projection);

  d3.select('.speed').on('keyup', function() {
    if (event.keyCode === 13) {
      return draw_point_and_prediction();
    }
  });

  d3.select('.course').on('keyup', function() {
    if (event.keyCode === 13) {
      return draw_point_and_prediction();
    }
  });

  d3.select('.lat').on('keyup', function() {
    if (event.keyCode === 13) {
      lat = d3.select('.lat').node().value;
      return draw_point_and_prediction();
    }
  });

  d3.select('.lon').on('keyup', function() {
    if (event.keyCode === 13) {
      lon = d3.select('.lon').node().value;
      return draw_point_and_prediction();
    }
  });

  d3.select('.time').on('change', function() {
    return draw_point_and_prediction();
  });

  d3.select('.basic_class').on('change', function() {
    return draw_point_and_prediction();
  });

  d3.select('.algorithm').on('change', function() {
    return draw_point_and_prediction();
  });
  
  d3.select('.datetime').on('keyup', function() {
    if (event.keyCode === 13) {
      return draw_point_and_prediction();
    }
  });

  color = d3.scaleLinear().domain([0, 1]).range(["transparent", "red"]);
  
  //color_y = d3.scaleLinear().domain([0, 140000]).range(["transparent", "#99CCFF"]);
  color_y = d3.scaleLinear().domain([0, 140000]).range(["white", "blue"]); ;

  color_y = d3.scaleLog().domain([0, 1470207]).range(["white", "blue"]).interpolate(d3.interpolate); ;
  //color_y = d3.scaleLog().domain([0, 1470207]).range(["transparent", "blue"]);
  var color_y = d3.scaleLog() 
    .domain([1, 1470207]) 
    .range(["white", "blue"]) 

    // Using interpolate 
    .interpolate(d3.interpolate); 
  //color_y = d3.scaleLinear().domain([0, 0.5]).range(["transparent", "blue"]);
  
  //d3.csv("dump/classes.csv", function(data) {
  d3.csv("dump/cells.csv", function(data) {  
    var all_cells, cells, enter_cells;
    cells = route_g.selectAll('.cell_route').data(data);
    
    data.forEach(function(d) {
      d.bottom_left = projection([+d.col * CELLSIZE, +d.row * CELLSIZE]);
      
      return d.top_right = projection([(+d.col + 1) * CELLSIZE, (+d.row + 1) * CELLSIZE]);
    });
    enter_cells = cells.enter().append('path').attrs({
      "class": 'cell_route'
    });
    all_cells = cells.merge(enter_cells);
    return all_cells.attrs({
      d: function(d) {
        return "M " + d.bottom_left[0] + " " + d.bottom_left[1] + " L " + d.top_right[0] + " " + d.bottom_left[1] + " L " + d.top_right[0] + " " + d.top_right[1] + " L " + d.bottom_left[0] + " " + d.top_right[1] + " z";
      }
    }).style('fill', function(d) {
        return color_y(d.value);
      }).on('mouseover', function(d){
        console.log(d.value)
        //console.log(d.value+' log: '+color_y(d.value))
      })
    ;
    
  });

  d3.json('http://wafi.iit.cnr.it/webvis/tmp/europe.topo.json', function(error, geo_data) {

    /* Countries
     */
    var countries;
    countries = countries_europe_g.selectAll('.country').data(topojson.feature(geo_data, geo_data.objects.europe).features);
    return countries.enter().append('path').attrs({
      "class": 'country',
      d: path_generator
    });
  });

  d3.json('http://wafi.iit.cnr.it/webvis/tmp/africa.topo.json', function(error, geo_data) {

    /* Countries
     */
    var countries;
    countries = countries_africa_g.selectAll('.country').data(topojson.feature(geo_data, geo_data.objects.collection).features);
    return countries.enter().append('path').attrs({
      "class": 'country',
      d: path_generator
    });
  });

  draw_point_and_prediction = function() {
    var all_ellipse, all_line, all_point, api, course, ellipse, enter_ellipse, enter_line, enter_point, latitudine_gradi, line, longitudine_gradi, point, speed, xg, yg;
    speed = d3.select('.speed').node().value;
    course = d3.select('.course').node().value;
    time = d3.select('.time').node().value;
    basic_class = d3.select('.basic_class').node().value;
    d3.select('.lat').property('value', lat);
    d3.select('.lon').property('value', lon);
    algorithm = d3.select('.algorithm').node().value;
    datetime = d3.select('.datetime').node().value;
    console.log(datetime);
    coordinates = [lon, lat];
    api = "http://wafi.iit.cnr.it/osiris1/osiris_fo/SRP-2.0/API/predict.php?latitude=" + lat + "&longitude=" + lon + "&heading=" + course + "&sog=" + speed + "&basic_class=" + basic_class + '&date="' + datetime + '"';
    //json = "/data/owncloud/Shared/OSIRIS_REPOSITORY/2018_0503/S1B_IW_GRDH_1SDV_20180503T045608_20180503T045633_010752_013A51_110E/SRP/route_prediction.json";
    console.log(api);
    var start_time = new Date().getTime();
    d3.json(api, function(data) {
      var all_cells, array_grid, cells, enter_cells, enter_titles;
      array_grid = [];
      d3.selectAll('title').remove();
      console.log(data);
      data.features.forEach(function(d) {
        if (d.properties['probability_' + time]) {
          return array_grid.push({
            'row': d.properties.row,
            'col': d.properties.column,
            'value': d.properties['probability_' + time]
          });
        }
      });
      //console.log(array_grid);
      cells = prediction_g.selectAll('.cell').data(array_grid);
      array_grid.forEach(function(d) {
        d.bottom_left = projection([+d.col * CELLSIZE, +d.row * CELLSIZE]);
        return d.top_right = projection([(+d.col + 1) * CELLSIZE, (+d.row + 1) * CELLSIZE]);
      });
      enter_cells = cells.enter().append('path').attrs({
        "class": 'cell'
      });
      all_cells = cells.merge(enter_cells);
      all_cells.attrs({
        d: function(d) {
          return "M " + d.bottom_left[0] + " " + d.bottom_left[1] + " L " + d.top_right[0] + " " + d.bottom_left[1] + " L " + d.top_right[0] + " " + d.top_right[1] + " L " + d.bottom_left[0] + " " + d.top_right[1] + " z";
        }
      }).style('fill', function(d) {
        return color(d.value);
      });
      cells.exit().remove();
      return enter_titles = all_cells.append('title').text(function(d) {
        return d.value * 100 + '%';
      });
    });
    var end_time = new Date().getTime();
    var elapsed_time = end_time - start_time;
    console.log("elapsed time in seconds: " + elapsed_time);
    ellipse = ellipse_g.selectAll('.ellipse').data([coordinates]);
    enter_ellipse = ellipse.enter().append('ellipse').attrs({
      "class": 'ellipse'
    });
    all_ellipse = ellipse.merge(enter_ellipse);
    latitudine_gradi = 11095.324;
    longitudine_gradi = 9051.521;
    yg = max_speed * 0.51444 * time * 60 / latitudine_gradi;
    xg = max_speed * 0.51444 * time * 60 / longitudine_gradi;
    all_ellipse.attrs({
      cx: function(d) {
        return projection(d)[0];
      },
      cy: function(d) {
        return projection(d)[1];
      },
      rx: projection([xg, 0])[0] - projection([0, 0])[0],
      ry: Math.abs(projection([0, yg])[1] - projection([0, 0])[1])
    });
    point = point_line_g.selectAll('.point').data([coordinates]);
    enter_point = point.enter().append('circle').attrs({
      "class": 'point'
    });
    all_point = point.merge(enter_point);
    all_point.attrs({
      cx: function(d) {
        return projection(d)[0];
      },
      cy: function(d) {
        return projection(d)[1];
      },
      r: 0.08
    });
    line = point_line_g.selectAll('.line').data([coordinates]);
    enter_line = line.enter().append('line').attrs({
      "class": 'line'
    });
    all_line = line.merge(enter_line);
    return all_line.attrs({
      x1: function(d) {
        return projection(d)[0];
      },
      y1: function(d) {
        return projection(d)[1];
      },
      x2: function(d) {
        return projection(d)[0];
      },
      y2: function(d) {
        return projection(d)[1] - speed / 20;
      },
      stroke: 'black',
      transform: function(d) {
        return "rotate(" + course + " " + (projection(d)[0]) + " " + (projection(d)[1]) + ")";
      }
    });
  };

  draw_point_and_prediction(lat, lon);

}).call(this);